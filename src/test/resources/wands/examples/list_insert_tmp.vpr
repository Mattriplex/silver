// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

/* This example encodes and specifies an iterative implementation of inserting
 * a value into a linked list. A magic wand is used to book-keep permissions.
 *
 * Notes:
 *  - It might take Silicon quite a while to verify this example, which is due
 *    to a problem with our sequence axiomatisation that can slow down Z3 quite
 *    a bit.
 *  - The additional two asserts are currently necessary because of a known
 *    incompleteness of Silicon related to recursive functions.
 *  - See list_insert_noseq.vpr for a version from which all sequences have
 *    been removed.
 */

field val: Int
field next: Ref

/* The usual linked-list predicate. */
predicate List(xs: Ref) {
	acc(xs.val) && acc(xs.next) && (xs.next != null ==> acc(List(xs.next)))
}

/* Returns the elements stored in the linked-list xs. */
function elems(xs: Ref): Seq[Int]
  requires acc(List(xs))
{ unfolding List(xs) in Seq(xs.val) ++ (xs.next == null ? Seq[Int]() : elems(xs.next)) }

/* Returns the head value of the linked-list xs. */
function head(xs: Ref): Int
  requires acc(List(xs))
{ unfolding List(xs) in xs.val }

/* Inserts value x at an appropriate position into the ordered linked-list xs, such that
 * the list remains ordered if it was in ascending order before.
 */
method insert(xs: Ref, x: Int) returns (i: Int)
  requires acc(List(xs))
  requires head(xs) < x
  ensures acc(List(xs))
  ensures elems(xs) == old(elems(xs))[0..i+1] ++ Seq(x) ++ old(elems(xs))[i+1..]
{
  var crt: Ref
  /* LHS */ var crtElems: Seq[Int]
  var nxt: Ref
  i := 0

  define A acc(List(crt)) /* LHS */ && elems(crt) == Seq(x) ++ crtElems
  define B acc(List(xs)) && elems(xs) == old(elems(xs))[0..i] ++ /* LHS */ (Seq(x) ++ crtElems) // lhs(elems(crt))

  /* LHS */ crtElems := elems(xs)
  unfold List(xs)
  crt := xs
  nxt := xs.next

  package A --* B

	/* Find the appropriate position for x in the linked-list. After the loop,
	 * crt points to the first node in the list s.t. crt.next is either null,
	 * or crt.next.val >= x. nxt is always equal to crt.next.
	 */
  while (nxt != null && head(nxt) < x)
    invariant 0 <= i && i < |old(elems(xs))|
    invariant nxt == null ==> i == |old(elems(xs))| - 1 /* INV2*/
    invariant acc(crt.val) && acc(crt.next)
    invariant nxt == crt.next
    invariant crt.val == old(elems(xs))[i] /* INV5 */
    invariant nxt != null ==> (acc(List(nxt)) && elems(nxt) == old(elems(xs))[i+1..])
    invariant A --* B
    invariant crtElems == Seq(crt.val) ++ (crt.next == null ? Seq[Int]() : elems(crt.next))
  {
    assert old(elems(xs))[i+1] == elems(nxt)[0]

    var prev: Ref := crt
    var oElems: Seq[Int] := crtElems
    var oi: Int := i

    /* LHS */ crtElems := elems(nxt)

    unfold List(nxt)
    crt := nxt
    nxt := nxt.next
    i := i + 1

    package (A) --* B {
        fold List(prev)
        //:: UnexpectedOutput(apply.failed:assertion.false, /silicon/issue/190/)
        //:: UnexpectedOutput(apply.failed:assertion.false, /carbon/issue/290/)
        apply (acc(List(prev)) && elems(prev) == Seq(x) ++ oElems) --*  (acc(List(xs)) && elems(xs) == old(elems(xs))[0..oi] ++ (Seq(x) ++ oElems))
    }
  }

  assert
    acc(List(crt))&& elems(crt) == Seq(x) ++ crtElems
      --*
    acc(List(xs)) && elems(xs) == old(elems(xs))[0..i] ++ (Seq(x) ++ crtElems)

	/* Create a new node with value x and append the list tail starting at nxt to it. */
  var node: Ref
  node := new(val, next)
  node.val := x
  node.next := nxt

  fold List(node)

//  assert old(elems(xs))[i+1..] == Seq[Int]()

//  assSeq(xs.val) ++ (xs.next == null ? Seq[Int]() : elems(xs.next))

  assert elems(node) == Seq(x) ++ old(elems(xs))[i+1..]
//  assert elems(node) == Seq(x) ++ Seq[Int]()

	/* Append the new node (and its tail) to the current node. */
  crt.next := node
  fold List(crt)

//  assert crtElems ++ Seq(x)

	/* Give up the sublist starting at crt and get back the original list *with*
	 * the newly inserted value.
	 */
//  apply A --* B
//  crtElems := elems(crt)

  assert
    acc(List(crt))&& elems(crt) == Seq(x) ++ crtElems
      --*
    acc(List(xs)) && elems(xs) == old(elems(xs))[0..i] ++ (Seq(x) ++ crtElems)

  //:: UnexpectedOutput(assert.failed:assertion.false, /carbon/issue/290/)
  assert acc(List(crt))&& elems(crt) == Seq(x) ++ crtElems

  apply
    acc(List(crt))&& elems(crt) == Seq(x) ++ crtElems
      --*
    acc(List(xs)) && elems(xs) == old(elems(xs))[0..i] ++ (Seq(x) ++ crtElems)
}

//APPENDED PERMISSION MODEL

domain _Perm {
    function unit(): Perm 
    function full(): Perm
    function plus(_x: Perm, _y: Perm): Perm
    function minus(_x: Perm, _y: Perm): Perm
    function geq(_x: Perm, _y: Perm): Bool
    function joinable(_x: Perm, _y: Perm): Bool

    function times(_x: Perm, _y: Perm): Perm

    //Auxiliary functions
    function share(_x: Rational): Perm
    function valid_share(_x: Rational): Bool
    function biConstr(Int, Int): Perm

    //Axioms
    axiom axBiConstr {forall _a: Int, _b: Int :: {biConstr(_a, _b)} biConstr(_a, _b) == share(_a/_b)}


    axiom axValid { forall _x: Rational :: {valid_share(_x)}
        valid_share(_x) <==> (_x >= 0/1 && _x <= 1/1)
    }
    axiom axUnit { unit() == share(0/1) }
    axiom axFull { full() == share(1/1) }
    axiom axInj { forall _a: Rational, _b: Rational :: { share(_a), share(_b) }
        share(_a) == share(_b) ==> _a == _b
    }
    axiom axPlus { forall _a: Rational, _b: Rational :: { plus(share(_a), share(_b)) }
        joinable(share(_a), share(_b)) ==> plus(share(_a), share(_b)) == share(_a + _b)
    }
    axiom axMinus { forall _a: Rational, _b: Rational :: { minus(share(_a), share(_b)) }
        geq(share(_a), share(_b)) ==> minus(share(_a), share(_b)) == share(_a - _b)
    }
    axiom axCanJoin { forall _a: Rational, _b: Rational :: { joinable(share(_a), share(_b)) }
        valid_share(_a) && valid_share(_b) ==> (joinable(share(_a), share(_b)) == valid_share(_a + _b))
    }
    axiom axGeq { forall _a: Rational, _b: Rational :: { geq(share(_a), share(_b)) }
        valid_share(_a) && valid_share(_b) ==> (geq(share(_a), share(_b)) <==> valid_share(_a - _b))
    }
    axiom axMul { forall _a: Rational, _b: Rational :: {times(share(_a), share(_b))} times(share(_a), share(_b)) == share(_a * _b)}

    axiom axJoinComm {forall _p: Perm, _q: Perm :: {plus(_p, _q)} plus(_p, _q) == plus(_q, _p)}
    axiom axJoinAssoc {forall _p: Perm, _q: Perm, _r: Perm :: {plus(plus(_p, _q), _r)} plus(plus(_p, _q), _r) == plus(_p, plus(_q, _r))}
    axiom axJoinCancel { forall _p: Perm, _q: Perm, _x: Perm :: {plus(_p, _x), plus(_q, _x)} plus(_p, _x) == plus(_q, _x) ==> _p == _q}

    axiom axUnitGeq { forall _p: Perm :: {geq(_p, unit())} geq(_p, unit())}
    axiom axUnitGeq2 { forall _p: Perm :: {geq(unit(),_p)} geq(unit(),_p) <==> _p == unit()}
    axiom axFullGeq { forall _p: Perm :: {geq(full(),_p)} geq(full(),_p)}
    axiom axFullGeq2 { forall _p: Perm :: {geq(_p, full())} geq(_p, full()) <==> _p == full()}
    axiom axGeqId { forall _p: Perm :: {geq(_p, _p)} geq(_p, _p)}
    axiom axMinusId { forall _p: Perm :: {minus(_p, _p)} minus(_p, _p) == unit()}


    axiom axUnitJoin { forall _p: Perm :: {plus(unit(),_p)} plus(unit(),_p) == _p}
    axiom axUnitJoinable { forall _p: Perm :: {joinable(_p, unit())} joinable(_p, unit())}
    axiom axJoinableComm { forall _p: Perm, _q: Perm :: {joinable(_p, _q)} joinable(_p, _q) == joinable(_q,_p)}
    axiom axTimes0 { forall _p: Perm :: {times(unit(),_p)} times(unit(),_p) == unit()}
    axiom axTimes1 { forall _p: Perm :: {times(full(),_p)} times(full(),_p) == _p}

    axiom axGeqPlus { forall _a: Perm, _x: Perm, _y: Perm :: {geq(_a, plus(_x, _y))} geq(_a, plus(_x, _y)) ==> geq(_a, _x)}
    axiom axGeqMinus {forall _a: Perm, _x: Perm, _y: Perm :: {geq(_a, plus(_x, _y))} geq(_a, plus(_x, _y)) ==> geq(minus(_a, _y), _x)}
    axiom axMinusUneq { forall _p: Perm, _q: Perm :: {geq(_p, _q)} geq(_p, _q) && _p != _q ==> minus(_p, _q) != unit()}

    axiom axPositive {forall _p: Perm, _q: Perm :: {plus(_p, _q)} plus(_p, _q) == unit() ==> _p == unit() && _q == unit()}
    axiom axPlusGeq {forall _p: Perm, _q: Perm :: {geq(plus(_p, _q), _p)} /*joinable(_p, _q) ==>*/ geq(plus(_p, _q), _p)}
    axiom axMinusCancel {forall _p: Perm, _q: Perm :: {minus(plus(_p, _q), _q)} minus(plus(_p, _q), _q) == _p}

}


domain _Scalar { //Fractional scalars
    function zeroS(): Scalar 
    function oneS(): Scalar
    function plusS(_x: Scalar, _y: Scalar): Scalar
    function minusS(_x: Scalar, _y: Scalar): Scalar
    function geqS(_x: Scalar, _y: Scalar): Bool
    //function joinable(_x: Perm, _y: Perm): Bool //not needed, joinability depends on perms' joinable predicate

    function timesS(_x: Scalar, _y: Scalar): Scalar
    function applyS(_x: Scalar, _y: Perm): Perm
    //Auxiliary functions
//Integer scalars
    function stack(_r: Rational) : Scalar
    axiom axStack0 { stack(0/1) == zeroS()}
    axiom axStack1 { stack(1/1) == oneS() }
    axiom axPlusStack { forall _n: Rational, _m: Rational :: {plusS(stack(_n), stack(_m))} _m >= 0/1 ==> _n >= 0/1 ==> plusS(stack(_n), stack(_m)) == stack(_m + _n)}
    axiom axGeqStack { forall _n: Rational, _m: Rational :: {geqS(stack(_n), stack(_m))} _m >= 0/1 ==> _n >= 0/1 ==> geqS(stack(_n), stack(_m)) <==> _n >= _m}
    axiom axMinusStack { forall _n: Rational, _m: Rational ::{minusS(stack(_n), stack(_m))} _m >= 0/1 ==> _n >= 0/1 ==> geqS(stack(_n), stack(_m)) ==> minusS(stack(_n), stack(_m)) == stack(_n - _m)}
    axiom axStackApply { forall _p: Rational, _n: Rational :: {applyS(stack(_n), share(_p))} valid_share(_n * _p) ==> applyS(stack(_n), share(_p)) == share(_n * _p)}
    axiom axStackTimes { forall _n: Rational, _m: Rational :: {timesS(stack(_n), stack(_m))} _m >= 0/1 ==> _n >= 0/1 ==> timesS(stack(_n), stack(_m)) == stack(_m * _n)}

//PLUS
    axiom axPlusZero{ forall _s: Scalar :: {plusS(zeroS(),_s)} plusS(zeroS(),_s) == _s}
    axiom axPlusComm {forall _s: Scalar, _t: Scalar :: {plusS(_s, _t)} plusS(_s, _t) == plusS(_t, _s)}

//APPLY
//one = identity function, zero = constant unit() function
    axiom applyZero { forall _p: Perm :: {applyS(zeroS(), _p)} applyS(zeroS(), _p) == unit() }
    axiom applyOne { forall _p: Perm :: {applyS(oneS(), _p)} applyS(oneS(), _p) == _p }


//TIMES

    axiom axTimes0S { forall _s: Scalar :: {timesS(zeroS(), _s)} timesS(zeroS(),_s) == zeroS()}
    axiom axTimes1S { forall _s: Scalar :: {timesS(oneS(),_s)} timesS(oneS(),_s) == _s}
    axiom axTimesComm {forall _s: Scalar, _t: Scalar :: {timesS(_s, _t)} timesS(_s, _t) == timesS(_t, _s)}

//GEQ
    axiom axGeqZero { forall _s: Scalar :: {geqS(_s, zeroS())} geqS(_s, zeroS())}
//MINUS
    axiom axMinusZero { forall _s: Scalar :: {geqS(_s, zeroS())} geqS(_s, zeroS())}

    //additional axioms
    axiom axGeqPlusS { forall _a: Scalar, _x: Scalar, _y: Scalar :: {geqS(_a, plusS(_x, _y))} geqS(_a, plusS(_x, _y)) ==> geqS(_a, _x)}
    axiom axgeqSMinusS {forall _a: Scalar, _x: Scalar, _y: Scalar :: {geqS(_a, plusS(_x, _y))} geqS(_a, plusS(_x, _y)) ==> geqS(minusS(_a, _y), _x)}
    axiom axMinusUneqS { forall _p: Scalar, _q: Scalar :: {geqS(_p, _q)} geqS(_p, _q) && _p != _q ==> minusS(_p, _q) != zeroS()}

    axiom axPositiveS {forall _p: Scalar, _q: Scalar :: {plusS(_p, _q)} plusS(_p, _q) == zeroS() ==> _p == zeroS() && _q == zeroS()}
    axiom axPlusgeqS {forall _p: Scalar, _q: Scalar :: {geqS(plusS(_p, _q), _p)}geqS(plusS(_p, _q), _p)}
    axiom axMinusCancelS {forall _p: Scalar, _q: Scalar :: {minusS(plusS(_p, _q), _q)} minusS(plusS(_p, _q), _q) == _p}

}