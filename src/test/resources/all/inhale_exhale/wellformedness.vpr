// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

/*
Even though one of the InhaleExhale expression branches might never get
executed, both of them must be checked for wellformedness.

The following methods should fail to verify because contracts are not
self-framing.
*/
field x: Int

/*
Sanity check: wellformedness checks are performed when InhaleExhale
expressions are not used.
*/

method s0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires this.x == 0
{
}

method s1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures this.x == 0
{
  inhale acc(this.x) && this.x == 0
}

method s2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires this != null && this.x == 0
{
}

method s3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures this != null && this.x == 0
{
  inhale acc(this.x) && this.x == 0
}

/*
The same tests with InhaleExhale expressions.
*/

/*
Inhale.
*/

method i0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this.x == 0, true]
{
}

method i1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this.x == 0, true]
{
  inhale acc(this.x) && this.x == 0
}

method i2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this != null && this.x == 0, true]
{
}

method i3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this != null && this.x == 0, true]
{
  inhale acc(this.x) && this.x == 0
}

/*
Exhale.
*/

method e0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  requires [true, this.x == 0]
{
}

method e1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  ensures [true, this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

method e2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  requires [true, this != null && this.x == 0]
{
}

method e3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  ensures [true, this != null && this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

/*
Both.
*/

method ie0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this.x == 0, this.x == 0]
{
}

method ie1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this.x == 0, this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

method ie2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this != null && this.x == 0, this != null && this.x == 0]
{
}

method ie3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this != null && this.x == 0, this != null && this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

/*
More interesting combinations.
*/

/*
    Conditions to check for wellformedness:
    1.   acc(this.x) && true
    2.   true && this != null && this.x == 0 <-- should give an error
    Precondition verified with method body: acc(this.x) && true
*/
method t1(this: Ref)
  requires [acc(this.x), true]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  requires [true, this != null && this.x == 0]
{
}

/*
    Conditions to check for wellformedness:
    1.   true && this != null && this.x == 0 <-- should give an error
    2.   acc(this.x) && true
    Precondition verified with method body: true && this != null && this.x == 0
*/
method t2(this: Ref)
  requires [true, acc(this.x)]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this != null && this.x == 0, true]
{
}

/*
    Conditions to check for wellformedness:
    1.   true && this != null && this.x == 0 <-- should give an error
    2.   acc(this.x) && true
    Postcondition verified with method body: true && this != null && this.x == 0
*/
method t3(this: Ref)
  ensures [acc(this.x), true]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  ensures [true, this != null && this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

/*
    Conditions to check for wellformedness:
    1.   acc(this.x) && true
    2.   true && this != null && this.x == 0 <-- should give an error
    Postcondition verified with method body: acc(this.x) && true
*/
method t4(this: Ref)
  ensures [true, acc(this.x)]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this != null && this.x == 0, true]
{
  inhale acc(this.x) && this.x == 0
}

//APPENDED PERMISSION MODEL

domain _Perm {
    function unit(): Perm 
    function full(): Perm
    function plus(x: Perm, y: Perm): Perm
    function minus(x: Perm, y: Perm): Perm
    function geq(x: Perm, y: Perm): Bool
    function joinable(x: Perm, y: Perm): Bool

    function times(x: Perm, y: Perm): Perm

    //Auxiliary functions
    function share(x: Rational): Perm
    function valid_share(x: Rational): Bool
    function biConstr(Int, Int): Perm

    //Axioms
    axiom axBiConstr {forall a: Int, b: Int :: {biConstr(a, b)} biConstr(a, b) == share(a/b)}


    axiom axValid { forall x: Rational :: {valid_share(x)}
        valid_share(x) <==> (x >= 0/1 && x <= 1/1)
    }
    axiom axUnit { unit() == share(0/1) }
    axiom axFull { full() == share(1/1) }
    axiom axInj { forall a: Rational, b: Rational :: { share(a), share(b) }
        share(a) == share(b) ==> a == b
    }
    axiom axPlus { forall a: Rational, b: Rational :: { plus(share(a), share(b)) }
        joinable(share(a), share(b)) ==> plus(share(a), share(b)) == share(a + b)
    }
    axiom axMinus { forall a: Rational, b: Rational :: { minus(share(a), share(b)) }
        geq(share(a), share(b)) ==> minus(share(a), share(b)) == share(a - b)
    }
    axiom axCanJoin { forall a: Rational, b: Rational :: { joinable(share(a), share(b)) }
        joinable(share(a), share(b)) <==> valid_share(a) && valid_share(b) && valid_share(a + b)
    }
    axiom axGeq { forall a: Rational, b: Rational :: { geq(share(a), share(b)) }
        geq(share(a), share(b)) <==> valid_share(a) && valid_share(b) && valid_share(a - b)
    }
    axiom axMul { forall a: Rational, b: Rational :: {times(share(a), share(b))} times(share(a), share(b)) == share(a * b)}

    axiom axJoinComm {forall p: Perm, q: Perm :: {plus(p, q)} plus(p, q) == plus(q, p)}
    axiom axJoinAssoc {forall p: Perm, q: Perm, r: Perm :: {plus(plus(p, q), r)} plus(plus(p, q), r) == plus(p, plus(q, r))}
    axiom axJoinCancel { forall p : Perm, q: Perm, x: Perm :: {plus(p, x), plus(q, x)} plus(p, x) == plus(q, x) ==> p == q}

    axiom axUnitGeq { forall p: Perm :: {geq(p, unit())} geq(p, unit())}
    axiom axUnitGeq2 { forall p: Perm :: {geq(unit(), p)} geq(unit(), p) <==> p == unit()}
    axiom axFullGeq { forall p: Perm :: {geq(full(), p)} geq(full(), p)}
    axiom axFullGeq2 { forall p: Perm :: {geq(p, full())} geq(p, full()) <==> p == full()}

    axiom axUnitJoin { forall p: Perm :: {plus(unit(), p)} plus(unit(), p) == p}
    axiom axUnitJoinable { forall p: Perm :: {joinable(p, unit())} joinable(p, unit())}
    axiom axJoinableComm { forall p: Perm, q: Perm :: {joinable(p, q)} joinable(p, q) == joinable(q, p)}
    axiom axTimes0 { forall p: Perm :: {times(unit(), p)} times(unit(), p) == unit()}
    axiom axTimes1 { forall p: Perm :: {times(full(), p)} times(unit(), p) == p}

    axiom axGeqPlus { forall a: Perm, x: Perm, y: Perm :: {geq(a, plus(x, y))} geq(a, plus(x, y)) ==> geq(a, x)}
    axiom axGeqMinus {forall a: Perm, x: Perm, y: Perm :: {geq(a, plus(x, y))} geq(a, plus(x, y)) && joinable(x, y) <==> geq(minus(a, y), x) && geq(a, y)}

}
