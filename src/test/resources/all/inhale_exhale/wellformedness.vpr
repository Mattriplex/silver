// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

/*
Even though one of the InhaleExhale expression branches might never get
executed, both of them must be checked for wellformedness.

The following methods should fail to verify because contracts are not
self-framing.
*/
field x: Int

/*
Sanity check: wellformedness checks are performed when InhaleExhale
expressions are not used.
*/

method s0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires this.x == 0
{
}

method s1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures this.x == 0
{
  inhale acc(this.x) && this.x == 0
}

method s2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires this != null && this.x == 0
{
}

method s3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures this != null && this.x == 0
{
  inhale acc(this.x) && this.x == 0
}

/*
The same tests with InhaleExhale expressions.
*/

/*
Inhale.
*/

method i0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this.x == 0, true]
{
}

method i1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this.x == 0, true]
{
  inhale acc(this.x) && this.x == 0
}

method i2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this != null && this.x == 0, true]
{
}

method i3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this != null && this.x == 0, true]
{
  inhale acc(this.x) && this.x == 0
}

/*
Exhale.
*/

method e0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  requires [true, this.x == 0]
{
}

method e1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  ensures [true, this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

method e2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  requires [true, this != null && this.x == 0]
{
}

method e3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  ensures [true, this != null && this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

/*
Both.
*/

method ie0(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this.x == 0, this.x == 0]
{
}

method ie1(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this.x == 0, this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

method ie2(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this != null && this.x == 0, this != null && this.x == 0]
{
}

method ie3(this: Ref)
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this != null && this.x == 0, this != null && this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

/*
More interesting combinations.
*/

/*
    Conditions to check for wellformedness:
    1.   acc(this.x) && true
    2.   true && this != null && this.x == 0 <-- should give an error
    Precondition verified with method body: acc(this.x) && true
*/
method t1(this: Ref)
  requires [acc(this.x), true]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  requires [true, this != null && this.x == 0]
{
}

/*
    Conditions to check for wellformedness:
    1.   true && this != null && this.x == 0 <-- should give an error
    2.   acc(this.x) && true
    Precondition verified with method body: true && this != null && this.x == 0
*/
method t2(this: Ref)
  requires [true, acc(this.x)]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  requires [this != null && this.x == 0, true]
{
}

/*
    Conditions to check for wellformedness:
    1.   true && this != null && this.x == 0 <-- should give an error
    2.   acc(this.x) && true
    Postcondition verified with method body: true && this != null && this.x == 0
*/
method t3(this: Ref)
  ensures [acc(this.x), true]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  //:: MissingOutput(not.wellformed:insufficient.permission, /Silicon/issue/160/)
  ensures [true, this != null && this.x == 0]
{
  inhale acc(this.x) && this.x == 0
}

/*
    Conditions to check for wellformedness:
    1.   acc(this.x) && true
    2.   true && this != null && this.x == 0 <-- should give an error
    Postcondition verified with method body: acc(this.x) && true
*/
method t4(this: Ref)
  ensures [true, acc(this.x)]
  //:: ExpectedOutput(not.wellformed:insufficient.permission)
  ensures [this != null && this.x == 0, true]
{
  inhale acc(this.x) && this.x == 0
}

//APPENDED PERMISSION MODEL

domain _Perm {
    function unit(): Perm 
    function full(): Perm
    function plus(_x: Perm, _y: Perm): Perm
    function minus(_x: Perm, _y: Perm): Perm
    function geq(_x: Perm, _y: Perm): Bool
    function joinable(_x: Perm, _y: Perm): Bool

    function times(_x: Perm, _y: Perm): Perm

    //Auxiliary functions
    function share(_x: Rational): Perm
    function valid_share(_x: Rational): Bool
    function biConstr(Int, Int): Perm

    //Axioms
    axiom axBiConstr {forall _a: Int, _b: Int :: {biConstr(_a, _b)} biConstr(_a, _b) == share(_a/_b)}


    axiom axValid { forall _x: Rational :: {valid_share(_x)}
        valid_share(_x) <==> (_x >= 0/1 && _x <= 1/1)
    }
    axiom axUnit { unit() == share(0/1) }
    axiom axFull { full() == share(1/1) }
    axiom axInj { forall _a: Rational, _b: Rational :: { share(_a), share(_b) }
        share(_a) == share(_b) ==> _a == _b
    }
    axiom axPlus { forall _a: Rational, _b: Rational :: { plus(share(_a), share(_b)) }
        joinable(share(_a), share(_b)) ==> plus(share(_a), share(_b)) == share(_a + _b)
    }
    axiom axMinus { forall _a: Rational, _b: Rational :: { minus(share(_a), share(_b)) }
        geq(share(_a), share(_b)) ==> minus(share(_a), share(_b)) == share(_a - _b)
    }
    axiom axCanJoin { forall _a: Rational, _b: Rational :: { joinable(share(_a), share(_b)) }
        joinable(share(_a), share(_b)) <==> valid_share(_a) && valid_share(_b) && valid_share(_a + _b)
    }
    axiom axGeq { forall _a: Rational, _b: Rational :: { geq(share(_a), share(_b)) }
        geq(share(_a), share(_b)) <==> valid_share(_a) && valid_share(_b) && valid_share(_a - _b)
    }
    axiom axMul { forall _a: Rational, _b: Rational :: {times(share(_a), share(_b))} times(share(_a), share(_b)) == share(_a * _b)}

    axiom axJoinComm {forall _p: Perm, _q: Perm :: {plus(_p, _q)} plus(_p, _q) == plus(_q, _p)}
    axiom axJoinAssoc {forall _p: Perm, _q: Perm, _r: Perm :: {plus(plus(_p, _q), _r)} plus(plus(_p, _q), _r) == plus(_p, plus(_q, _r))}
    axiom axJoinCancel { forall _p: Perm, _q: Perm, _x: Perm :: {plus(_p, _x), plus(_q, _x)} plus(_p, _x) == plus(_q, _x) ==> _p == _q}

    axiom axUnitGeq { forall _p: Perm :: {geq(_p, unit())} geq(_p, unit())}
    axiom axUnitGeq2 { forall _p: Perm :: {geq(unit(),_p)} geq(unit(),_p) <==> _p == unit()}
    axiom axFullGeq { forall _p: Perm :: {geq(full(),_p)} geq(full(),_p)}
    axiom axFullGeq2 { forall _p: Perm :: {geq(_p, full())} geq(_p, full()) <==> _p == full()}

    axiom axUnitJoin { forall _p: Perm :: {plus(unit(),_p)} plus(unit(),_p) == _p}
    axiom axUnitJoinable { forall _p: Perm :: {joinable(_p, unit())} joinable(_p, unit())}
    axiom axJoinableComm { forall _p: Perm, _q: Perm :: {joinable(_p, _q)} joinable(_p, _q) == joinable(_q,_p)}
    axiom axTimes0 { forall _p: Perm :: {times(unit(),_p)} times(unit(),_p) == unit()}
    axiom axTimes1 { forall _p: Perm :: {times(full(),_p)} times(unit(),_p) == _p}

    axiom axGeqPlus { forall _a: Perm, _x: Perm, _y: Perm :: {geq(_a, plus(_x, _y))} geq(_a, plus(_x, _y)) ==> geq(_a, _x)}
    axiom axGeqMinus {forall _a: Perm, _x: Perm, _y: Perm :: {geq(_a, plus(_x, _y))} geq(_a, plus(_x, _y)) ==> geq(minus(_a, _y), _x)}
    axiom axMinusUneq { forall _p: Perm, _q: Perm :: {geq(_p, _q)} geq(_p, _q) && _p != _q ==> minus(_p, _q) != unit()}

}
